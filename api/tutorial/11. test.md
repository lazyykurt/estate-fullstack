# test 身份验证 api

创建两个，一个验证 token 是否正确，一个验证是否是 admin

在 test.route.js 中创建，
HTTP get 方法的 /should-be-logged-in
以及 get 方法的 /should-be-admin

```js
router.get("/should-be-logged-in", shouldBeLoggedIn);

router.get("/should-be-admin", shouldBeAdmin);
```

并添加到 app 中

```js
import testRouter from "./routes/test.route.js";
app.use("/api/test", testRouter);
```

创建 controller 操作
验证 token 的逻辑

```js
// shouldBeLoggedIn controller
export const shouldBeLoggedIn = async (req, res) => {
  // 拿到请求到的token
  const token = req.cookies.token;
  // 不存在，提示登录
  if (!token) {
    return res.status(401).json({ message: "You are not logged in." });
  }
  // token不正确，返回token错误
  jwt.verify(token, process.env.JWT_SECRET_KEY, async (err, payload) => {
    if (err) return res.status(403).json({message: "Token is not Valid!"})
  })

  // 成功登录并执行其他操作
  res.status.json({message: "You are Authenticated"})
};
```

jwt 验证 token，
参数 1，传入 token，
参数 2，传入密钥，
参数 3，传入异步操作，（err, payload）,
payload 为解密出的数据

我们在注册 token 时，会传入有用的数据，例如我们前面注册时，传入了用户的id，我们还能出入，是否属于管理员admin，`isAdmin = true`

作为解析出的数据集payload，
使用 payload.id 获取之前传入的id属性的值
```js
const token = jwt.sign(
  { id: user.id }, 
  process.env.JWT_SECRET_KEY, 
  { expiresIn: age }
);
```

中间token验证的操作，重复使用，可封装在外部，作为中间件

在middleware文件夹下，创建 verifyToken.js
```js
import jwt from "jsonwebtoken";

export const verifyToken = (req, res, next) => {
  const token = req.cookies.token;
 
  if (!token) {
    return res.status(401).json({ message: "You are not logged in." });
  }
  
  jwt.verify(token, process.env.JWT_SECRET_KEY, async (err, payload) => {
    if (err) return res.status(403).json({message: "Token is not Valid!"})
    req.userId = payload.id;

    next();
  })
}
```

我们在对应路由中，加入此中间件
```js
router.get("/should-be-logged-in", verifyToken, shouldBeLoggedIn);
```
verifyToken当中的next(), 就是我们后面的shouldBeLoggedIn操作。